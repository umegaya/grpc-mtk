// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_test_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_test_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_test_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_test_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_test_2eproto;
namespace mtktest {
class CloseReply;
struct CloseReplyDefaultTypeInternal;
extern CloseReplyDefaultTypeInternal _CloseReply_default_instance_;
class CloseRequest;
struct CloseRequestDefaultTypeInternal;
extern CloseRequestDefaultTypeInternal _CloseRequest_default_instance_;
class ConnectPayload;
struct ConnectPayloadDefaultTypeInternal;
extern ConnectPayloadDefaultTypeInternal _ConnectPayload_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class LoginTask;
struct LoginTaskDefaultTypeInternal;
extern LoginTaskDefaultTypeInternal _LoginTask_default_instance_;
class NotifyReply;
struct NotifyReplyDefaultTypeInternal;
extern NotifyReplyDefaultTypeInternal _NotifyReply_default_instance_;
class NotifyRequest;
struct NotifyRequestDefaultTypeInternal;
extern NotifyRequestDefaultTypeInternal _NotifyRequest_default_instance_;
class PingReply;
struct PingReplyDefaultTypeInternal;
extern PingReplyDefaultTypeInternal _PingReply_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class RaiseReply;
struct RaiseReplyDefaultTypeInternal;
extern RaiseReplyDefaultTypeInternal _RaiseReply_default_instance_;
class RaiseRequest;
struct RaiseRequestDefaultTypeInternal;
extern RaiseRequestDefaultTypeInternal _RaiseRequest_default_instance_;
class TaskReply;
struct TaskReplyDefaultTypeInternal;
extern TaskReplyDefaultTypeInternal _TaskReply_default_instance_;
class TaskRequest;
struct TaskRequestDefaultTypeInternal;
extern TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
class TextNotify;
struct TextNotifyDefaultTypeInternal;
extern TextNotifyDefaultTypeInternal _TextNotify_default_instance_;
class TextTransferTask;
struct TextTransferTaskDefaultTypeInternal;
extern TextTransferTaskDefaultTypeInternal _TextTransferTask_default_instance_;
}  // namespace mtktest
PROTOBUF_NAMESPACE_OPEN
template <>
::mtktest::CloseReply* Arena::CreateMaybeMessage<::mtktest::CloseReply>(Arena*);
template <>
::mtktest::CloseRequest* Arena::CreateMaybeMessage<::mtktest::CloseRequest>(Arena*);
template <>
::mtktest::ConnectPayload* Arena::CreateMaybeMessage<::mtktest::ConnectPayload>(Arena*);
template <>
::mtktest::Error* Arena::CreateMaybeMessage<::mtktest::Error>(Arena*);
template <>
::mtktest::LoginTask* Arena::CreateMaybeMessage<::mtktest::LoginTask>(Arena*);
template <>
::mtktest::NotifyReply* Arena::CreateMaybeMessage<::mtktest::NotifyReply>(Arena*);
template <>
::mtktest::NotifyRequest* Arena::CreateMaybeMessage<::mtktest::NotifyRequest>(Arena*);
template <>
::mtktest::PingReply* Arena::CreateMaybeMessage<::mtktest::PingReply>(Arena*);
template <>
::mtktest::PingRequest* Arena::CreateMaybeMessage<::mtktest::PingRequest>(Arena*);
template <>
::mtktest::RaiseReply* Arena::CreateMaybeMessage<::mtktest::RaiseReply>(Arena*);
template <>
::mtktest::RaiseRequest* Arena::CreateMaybeMessage<::mtktest::RaiseRequest>(Arena*);
template <>
::mtktest::TaskReply* Arena::CreateMaybeMessage<::mtktest::TaskReply>(Arena*);
template <>
::mtktest::TaskRequest* Arena::CreateMaybeMessage<::mtktest::TaskRequest>(Arena*);
template <>
::mtktest::TextNotify* Arena::CreateMaybeMessage<::mtktest::TextNotify>(Arena*);
template <>
::mtktest::TextTransferTask* Arena::CreateMaybeMessage<::mtktest::TextTransferTask>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace mtktest {
enum ConnectPayload_LoginMode : int {
  ConnectPayload_LoginMode_Invalid = 0,
  ConnectPayload_LoginMode_Pending = 1,
  ConnectPayload_LoginMode_Failure = 2,
  ConnectPayload_LoginMode_ConnectPayload_LoginMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ConnectPayload_LoginMode_ConnectPayload_LoginMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ConnectPayload_LoginMode_IsValid(int value);
constexpr ConnectPayload_LoginMode ConnectPayload_LoginMode_LoginMode_MIN = static_cast<ConnectPayload_LoginMode>(0);
constexpr ConnectPayload_LoginMode ConnectPayload_LoginMode_LoginMode_MAX = static_cast<ConnectPayload_LoginMode>(2);
constexpr int ConnectPayload_LoginMode_LoginMode_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ConnectPayload_LoginMode_descriptor();
template <typename T>
const std::string& ConnectPayload_LoginMode_Name(T value) {
  static_assert(std::is_same<T, ConnectPayload_LoginMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoginMode_Name().");
  return ConnectPayload_LoginMode_Name(static_cast<ConnectPayload_LoginMode>(value));
}
template <>
inline const std::string& ConnectPayload_LoginMode_Name(ConnectPayload_LoginMode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ConnectPayload_LoginMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ConnectPayload_LoginMode_Parse(absl::string_view name, ConnectPayload_LoginMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectPayload_LoginMode>(
      ConnectPayload_LoginMode_descriptor(), name, value);
}
enum MessageTypes : int {
  Invalid_MessageType = 0,
  Ping = 1,
  Close = 2,
  Raise = 3,
  Task = 4,
  Notify = 5,
  Task_TextTransfer = 50,
  Task_Login = 51,
  Notify_Text = 100,
  MessageTypes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessageTypes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessageTypes_IsValid(int value);
constexpr MessageTypes MessageTypes_MIN = static_cast<MessageTypes>(0);
constexpr MessageTypes MessageTypes_MAX = static_cast<MessageTypes>(100);
constexpr int MessageTypes_ARRAYSIZE = 100 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
MessageTypes_descriptor();
template <typename T>
const std::string& MessageTypes_Name(T value) {
  static_assert(std::is_same<T, MessageTypes>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageTypes_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(MessageTypes_descriptor(), value);
}
inline bool MessageTypes_Parse(absl::string_view name, MessageTypes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageTypes>(
      MessageTypes_descriptor(), name, value);
}
enum ErrorCodes : int {
  Invalid_ErrorCode = 0,
  RaiseRequested = -1,
  ErrorCodes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorCodes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorCodes_IsValid(int value);
constexpr ErrorCodes ErrorCodes_MIN = static_cast<ErrorCodes>(-1);
constexpr ErrorCodes ErrorCodes_MAX = static_cast<ErrorCodes>(0);
constexpr int ErrorCodes_ARRAYSIZE = 0 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ErrorCodes_descriptor();
template <typename T>
const std::string& ErrorCodes_Name(T value) {
  static_assert(std::is_same<T, ErrorCodes>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorCodes_Name().");
  return ErrorCodes_Name(static_cast<ErrorCodes>(value));
}
template <>
inline const std::string& ErrorCodes_Name(ErrorCodes value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ErrorCodes_descriptor,
                                                 -1, 0>(
      static_cast<int>(value));
}
inline bool ErrorCodes_Parse(absl::string_view name, ErrorCodes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCodes>(
      ErrorCodes_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // int32 code = 1;
  void clear_code() ;
  ::int32_t code() const;
  void set_code(::int32_t value);

  private:
  ::int32_t _internal_code() const;
  void _internal_set_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mtktest.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class ConnectPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.ConnectPayload) */ {
 public:
  inline ConnectPayload() : ConnectPayload(nullptr) {}
  ~ConnectPayload() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectPayload(const ConnectPayload& from);
  ConnectPayload(ConnectPayload&& from) noexcept
    : ConnectPayload() {
    *this = ::std::move(from);
  }

  inline ConnectPayload& operator=(const ConnectPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectPayload& operator=(ConnectPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectPayload* internal_default_instance() {
    return reinterpret_cast<const ConnectPayload*>(
               &_ConnectPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConnectPayload& a, ConnectPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectPayload& from) {
    ConnectPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.ConnectPayload";
  }
  protected:
  explicit ConnectPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LoginMode = ConnectPayload_LoginMode;
  static constexpr LoginMode Invalid = ConnectPayload_LoginMode_Invalid;
  static constexpr LoginMode Pending = ConnectPayload_LoginMode_Pending;
  static constexpr LoginMode Failure = ConnectPayload_LoginMode_Failure;
  static inline bool LoginMode_IsValid(int value) {
    return ConnectPayload_LoginMode_IsValid(value);
  }
  static constexpr LoginMode LoginMode_MIN = ConnectPayload_LoginMode_LoginMode_MIN;
  static constexpr LoginMode LoginMode_MAX = ConnectPayload_LoginMode_LoginMode_MAX;
  static constexpr int LoginMode_ARRAYSIZE = ConnectPayload_LoginMode_LoginMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginMode_descriptor() {
    return ConnectPayload_LoginMode_descriptor();
  }
  template <typename T>
  static inline const std::string& LoginMode_Name(T value) {
    return ConnectPayload_LoginMode_Name(value);
  }
  static inline bool LoginMode_Parse(absl::string_view name, LoginMode* value) {
    return ConnectPayload_LoginMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoginModeFieldNumber = 1,
  };
  // .mtktest.ConnectPayload.LoginMode login_mode = 1;
  void clear_login_mode() ;
  ::mtktest::ConnectPayload_LoginMode login_mode() const;
  void set_login_mode(::mtktest::ConnectPayload_LoginMode value);

  private:
  ::mtktest::ConnectPayload_LoginMode _internal_login_mode() const;
  void _internal_set_login_mode(::mtktest::ConnectPayload_LoginMode value);

  public:
  // @@protoc_insertion_point(class_scope:mtktest.ConnectPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int login_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingRequest& from) {
    PingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSentFieldNumber = 1,
  };
  // uint64 sent = 1;
  void clear_sent() ;
  ::uint64_t sent() const;
  void set_sent(::uint64_t value);

  private:
  ::uint64_t _internal_sent() const;
  void _internal_set_sent(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:mtktest.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t sent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class PingReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.PingReply) */ {
 public:
  inline PingReply() : PingReply(nullptr) {}
  ~PingReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingReply(const PingReply& from);
  PingReply(PingReply&& from) noexcept
    : PingReply() {
    *this = ::std::move(from);
  }

  inline PingReply& operator=(const PingReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingReply& operator=(PingReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingReply* internal_default_instance() {
    return reinterpret_cast<const PingReply*>(
               &_PingReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PingReply& a, PingReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PingReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingReply& from) {
    PingReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.PingReply";
  }
  protected:
  explicit PingReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSentFieldNumber = 1,
  };
  // uint64 sent = 1;
  void clear_sent() ;
  ::uint64_t sent() const;
  void set_sent(::uint64_t value);

  private:
  ::uint64_t _internal_sent() const;
  void _internal_set_sent(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:mtktest.PingReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t sent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class CloseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mtktest.CloseRequest) */ {
 public:
  inline CloseRequest() : CloseRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CloseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseRequest(const CloseRequest& from);
  CloseRequest(CloseRequest&& from) noexcept
    : CloseRequest() {
    *this = ::std::move(from);
  }

  inline CloseRequest& operator=(const CloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseRequest& operator=(CloseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseRequest* internal_default_instance() {
    return reinterpret_cast<const CloseRequest*>(
               &_CloseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CloseRequest& a, CloseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.CloseRequest";
  }
  protected:
  explicit CloseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mtktest.CloseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class CloseReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mtktest.CloseReply) */ {
 public:
  inline CloseReply() : CloseReply(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CloseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseReply(const CloseReply& from);
  CloseReply(CloseReply&& from) noexcept
    : CloseReply() {
    *this = ::std::move(from);
  }

  inline CloseReply& operator=(const CloseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseReply& operator=(CloseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseReply* internal_default_instance() {
    return reinterpret_cast<const CloseReply*>(
               &_CloseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CloseReply& a, CloseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.CloseReply";
  }
  protected:
  explicit CloseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mtktest.CloseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class RaiseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.RaiseRequest) */ {
 public:
  inline RaiseRequest() : RaiseRequest(nullptr) {}
  ~RaiseRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RaiseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaiseRequest(const RaiseRequest& from);
  RaiseRequest(RaiseRequest&& from) noexcept
    : RaiseRequest() {
    *this = ::std::move(from);
  }

  inline RaiseRequest& operator=(const RaiseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaiseRequest& operator=(RaiseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaiseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaiseRequest* internal_default_instance() {
    return reinterpret_cast<const RaiseRequest*>(
               &_RaiseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RaiseRequest& a, RaiseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RaiseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaiseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaiseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaiseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaiseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RaiseRequest& from) {
    RaiseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaiseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.RaiseRequest";
  }
  protected:
  explicit RaiseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // int32 code = 1;
  void clear_code() ;
  ::int32_t code() const;
  void set_code(::int32_t value);

  private:
  ::int32_t _internal_code() const;
  void _internal_set_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mtktest.RaiseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class RaiseReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mtktest.RaiseReply) */ {
 public:
  inline RaiseReply() : RaiseReply(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RaiseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaiseReply(const RaiseReply& from);
  RaiseReply(RaiseReply&& from) noexcept
    : RaiseReply() {
    *this = ::std::move(from);
  }

  inline RaiseReply& operator=(const RaiseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaiseReply& operator=(RaiseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaiseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaiseReply* internal_default_instance() {
    return reinterpret_cast<const RaiseReply*>(
               &_RaiseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RaiseReply& a, RaiseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RaiseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaiseReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaiseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaiseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RaiseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RaiseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.RaiseReply";
  }
  protected:
  explicit RaiseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mtktest.RaiseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class TaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.TaskRequest) */ {
 public:
  inline TaskRequest() : TaskRequest(nullptr) {}
  ~TaskRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskRequest(const TaskRequest& from);
  TaskRequest(TaskRequest&& from) noexcept
    : TaskRequest() {
    *this = ::std::move(from);
  }

  inline TaskRequest& operator=(const TaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequest& operator=(TaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskRequest* internal_default_instance() {
    return reinterpret_cast<const TaskRequest*>(
               &_TaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TaskRequest& a, TaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskRequest& from) {
    TaskRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.TaskRequest";
  }
  protected:
  explicit TaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:mtktest.TaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class TaskReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.TaskReply) */ {
 public:
  inline TaskReply() : TaskReply(nullptr) {}
  ~TaskReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskReply(const TaskReply& from);
  TaskReply(TaskReply&& from) noexcept
    : TaskReply() {
    *this = ::std::move(from);
  }

  inline TaskReply& operator=(const TaskReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskReply& operator=(TaskReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskReply* internal_default_instance() {
    return reinterpret_cast<const TaskReply*>(
               &_TaskReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TaskReply& a, TaskReply& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskReply& from) {
    TaskReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.TaskReply";
  }
  protected:
  explicit TaskReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:mtktest.TaskReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class NotifyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.NotifyRequest) */ {
 public:
  inline NotifyRequest() : NotifyRequest(nullptr) {}
  ~NotifyRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyRequest(const NotifyRequest& from);
  NotifyRequest(NotifyRequest&& from) noexcept
    : NotifyRequest() {
    *this = ::std::move(from);
  }

  inline NotifyRequest& operator=(const NotifyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRequest& operator=(NotifyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRequest* internal_default_instance() {
    return reinterpret_cast<const NotifyRequest*>(
               &_NotifyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NotifyRequest& a, NotifyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyRequest& from) {
    NotifyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.NotifyRequest";
  }
  protected:
  explicit NotifyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:mtktest.NotifyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class NotifyReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mtktest.NotifyReply) */ {
 public:
  inline NotifyReply() : NotifyReply(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyReply(const NotifyReply& from);
  NotifyReply(NotifyReply&& from) noexcept
    : NotifyReply() {
    *this = ::std::move(from);
  }

  inline NotifyReply& operator=(const NotifyReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyReply& operator=(NotifyReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyReply* internal_default_instance() {
    return reinterpret_cast<const NotifyReply*>(
               &_NotifyReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NotifyReply& a, NotifyReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NotifyReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NotifyReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.NotifyReply";
  }
  protected:
  explicit NotifyReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mtktest.NotifyReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class TextNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.TextNotify) */ {
 public:
  inline TextNotify() : TextNotify(nullptr) {}
  ~TextNotify() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextNotify(const TextNotify& from);
  TextNotify(TextNotify&& from) noexcept
    : TextNotify() {
    *this = ::std::move(from);
  }

  inline TextNotify& operator=(const TextNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextNotify& operator=(TextNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextNotify* internal_default_instance() {
    return reinterpret_cast<const TextNotify*>(
               &_TextNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TextNotify& a, TextNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(TextNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextNotify* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextNotify& from) {
    TextNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.TextNotify";
  }
  protected:
  explicit TextNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:mtktest.TextNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class TextTransferTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.TextTransferTask) */ {
 public:
  inline TextTransferTask() : TextTransferTask(nullptr) {}
  ~TextTransferTask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextTransferTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextTransferTask(const TextTransferTask& from);
  TextTransferTask(TextTransferTask&& from) noexcept
    : TextTransferTask() {
    *this = ::std::move(from);
  }

  inline TextTransferTask& operator=(const TextTransferTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextTransferTask& operator=(TextTransferTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextTransferTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextTransferTask* internal_default_instance() {
    return reinterpret_cast<const TextTransferTask*>(
               &_TextTransferTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TextTransferTask& a, TextTransferTask& b) {
    a.Swap(&b);
  }
  inline void Swap(TextTransferTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextTransferTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextTransferTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextTransferTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextTransferTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextTransferTask& from) {
    TextTransferTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextTransferTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.TextTransferTask";
  }
  protected:
  explicit TextTransferTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // string text = 2;
  void clear_text() ;
  const std::string& text() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // uint32 msgid = 1;
  void clear_msgid() ;
  ::uint32_t msgid() const;
  void set_msgid(::uint32_t value);

  private:
  ::uint32_t _internal_msgid() const;
  void _internal_set_msgid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mtktest.TextTransferTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::uint32_t msgid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};// -------------------------------------------------------------------

class LoginTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mtktest.LoginTask) */ {
 public:
  inline LoginTask() : LoginTask(nullptr) {}
  ~LoginTask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoginTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginTask(const LoginTask& from);
  LoginTask(LoginTask&& from) noexcept
    : LoginTask() {
    *this = ::std::move(from);
  }

  inline LoginTask& operator=(const LoginTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginTask& operator=(LoginTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginTask* internal_default_instance() {
    return reinterpret_cast<const LoginTask*>(
               &_LoginTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LoginTask& a, LoginTask& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginTask& from) {
    LoginTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mtktest.LoginTask";
  }
  protected:
  explicit LoginTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginCidFieldNumber = 1,
    kMsgidFieldNumber = 2,
    kUsePendingFieldNumber = 3,
  };
  // uint64 login_cid = 1;
  void clear_login_cid() ;
  ::uint64_t login_cid() const;
  void set_login_cid(::uint64_t value);

  private:
  ::uint64_t _internal_login_cid() const;
  void _internal_set_login_cid(::uint64_t value);

  public:
  // uint32 msgid = 2;
  void clear_msgid() ;
  ::uint32_t msgid() const;
  void set_msgid(::uint32_t value);

  private:
  ::uint32_t _internal_msgid() const;
  void _internal_set_msgid(::uint32_t value);

  public:
  // bool use_pending = 3;
  void clear_use_pending() ;
  bool use_pending() const;
  void set_use_pending(bool value);

  private:
  bool _internal_use_pending() const;
  void _internal_set_use_pending(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mtktest.LoginTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t login_cid_;
    ::uint32_t msgid_;
    bool use_pending_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Error

// int32 code = 1;
inline void Error::clear_code() {
  _impl_.code_ = 0;
}
inline ::int32_t Error::code() const {
  // @@protoc_insertion_point(field_get:mtktest.Error.code)
  return _internal_code();
}
inline void Error::set_code(::int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:mtktest.Error.code)
}
inline ::int32_t Error::_internal_code() const {
  return _impl_.code_;
}
inline void Error::_internal_set_code(::int32_t value) {
  ;
  _impl_.code_ = value;
}

// string message = 2;
inline void Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:mtktest.Error.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Error::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mtktest.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mtktest.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:mtktest.Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mtktest.Error.message)
}

// -------------------------------------------------------------------

// ConnectPayload

// .mtktest.ConnectPayload.LoginMode login_mode = 1;
inline void ConnectPayload::clear_login_mode() {
  _impl_.login_mode_ = 0;
}
inline ::mtktest::ConnectPayload_LoginMode ConnectPayload::login_mode() const {
  // @@protoc_insertion_point(field_get:mtktest.ConnectPayload.login_mode)
  return _internal_login_mode();
}
inline void ConnectPayload::set_login_mode(::mtktest::ConnectPayload_LoginMode value) {
   _internal_set_login_mode(value);
  // @@protoc_insertion_point(field_set:mtktest.ConnectPayload.login_mode)
}
inline ::mtktest::ConnectPayload_LoginMode ConnectPayload::_internal_login_mode() const {
  return static_cast<::mtktest::ConnectPayload_LoginMode>(_impl_.login_mode_);
}
inline void ConnectPayload::_internal_set_login_mode(::mtktest::ConnectPayload_LoginMode value) {
  ;
  _impl_.login_mode_ = value;
}

// -------------------------------------------------------------------

// PingRequest

// uint64 sent = 1;
inline void PingRequest::clear_sent() {
  _impl_.sent_ = ::uint64_t{0u};
}
inline ::uint64_t PingRequest::sent() const {
  // @@protoc_insertion_point(field_get:mtktest.PingRequest.sent)
  return _internal_sent();
}
inline void PingRequest::set_sent(::uint64_t value) {
  _internal_set_sent(value);
  // @@protoc_insertion_point(field_set:mtktest.PingRequest.sent)
}
inline ::uint64_t PingRequest::_internal_sent() const {
  return _impl_.sent_;
}
inline void PingRequest::_internal_set_sent(::uint64_t value) {
  ;
  _impl_.sent_ = value;
}

// -------------------------------------------------------------------

// PingReply

// uint64 sent = 1;
inline void PingReply::clear_sent() {
  _impl_.sent_ = ::uint64_t{0u};
}
inline ::uint64_t PingReply::sent() const {
  // @@protoc_insertion_point(field_get:mtktest.PingReply.sent)
  return _internal_sent();
}
inline void PingReply::set_sent(::uint64_t value) {
  _internal_set_sent(value);
  // @@protoc_insertion_point(field_set:mtktest.PingReply.sent)
}
inline ::uint64_t PingReply::_internal_sent() const {
  return _impl_.sent_;
}
inline void PingReply::_internal_set_sent(::uint64_t value) {
  ;
  _impl_.sent_ = value;
}

// -------------------------------------------------------------------

// CloseRequest

// -------------------------------------------------------------------

// CloseReply

// -------------------------------------------------------------------

// RaiseRequest

// int32 code = 1;
inline void RaiseRequest::clear_code() {
  _impl_.code_ = 0;
}
inline ::int32_t RaiseRequest::code() const {
  // @@protoc_insertion_point(field_get:mtktest.RaiseRequest.code)
  return _internal_code();
}
inline void RaiseRequest::set_code(::int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:mtktest.RaiseRequest.code)
}
inline ::int32_t RaiseRequest::_internal_code() const {
  return _impl_.code_;
}
inline void RaiseRequest::_internal_set_code(::int32_t value) {
  ;
  _impl_.code_ = value;
}

// string message = 2;
inline void RaiseRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RaiseRequest::message() const {
  // @@protoc_insertion_point(field_get:mtktest.RaiseRequest.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RaiseRequest::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mtktest.RaiseRequest.message)
}
inline std::string* RaiseRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mtktest.RaiseRequest.message)
  return _s;
}
inline const std::string& RaiseRequest::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RaiseRequest::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RaiseRequest::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* RaiseRequest::release_message() {
  // @@protoc_insertion_point(field_release:mtktest.RaiseRequest.message)
  return _impl_.message_.Release();
}
inline void RaiseRequest::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mtktest.RaiseRequest.message)
}

// -------------------------------------------------------------------

// RaiseReply

// -------------------------------------------------------------------

// TaskRequest

// string text = 1;
inline void TaskRequest::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TaskRequest::text() const {
  // @@protoc_insertion_point(field_get:mtktest.TaskRequest.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskRequest::set_text(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mtktest.TaskRequest.text)
}
inline std::string* TaskRequest::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mtktest.TaskRequest.text)
  return _s;
}
inline const std::string& TaskRequest::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TaskRequest::_internal_set_text(const std::string& value) {
  ;


  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskRequest::_internal_mutable_text() {
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskRequest::release_text() {
  // @@protoc_insertion_point(field_release:mtktest.TaskRequest.text)
  return _impl_.text_.Release();
}
inline void TaskRequest::set_allocated_text(std::string* value) {
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mtktest.TaskRequest.text)
}

// -------------------------------------------------------------------

// TaskReply

// string text = 1;
inline void TaskReply::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TaskReply::text() const {
  // @@protoc_insertion_point(field_get:mtktest.TaskReply.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskReply::set_text(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mtktest.TaskReply.text)
}
inline std::string* TaskReply::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mtktest.TaskReply.text)
  return _s;
}
inline const std::string& TaskReply::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TaskReply::_internal_set_text(const std::string& value) {
  ;


  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskReply::_internal_mutable_text() {
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskReply::release_text() {
  // @@protoc_insertion_point(field_release:mtktest.TaskReply.text)
  return _impl_.text_.Release();
}
inline void TaskReply::set_allocated_text(std::string* value) {
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mtktest.TaskReply.text)
}

// -------------------------------------------------------------------

// NotifyRequest

// string text = 1;
inline void NotifyRequest::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& NotifyRequest::text() const {
  // @@protoc_insertion_point(field_get:mtktest.NotifyRequest.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyRequest::set_text(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mtktest.NotifyRequest.text)
}
inline std::string* NotifyRequest::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mtktest.NotifyRequest.text)
  return _s;
}
inline const std::string& NotifyRequest::_internal_text() const {
  return _impl_.text_.Get();
}
inline void NotifyRequest::_internal_set_text(const std::string& value) {
  ;


  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* NotifyRequest::_internal_mutable_text() {
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* NotifyRequest::release_text() {
  // @@protoc_insertion_point(field_release:mtktest.NotifyRequest.text)
  return _impl_.text_.Release();
}
inline void NotifyRequest::set_allocated_text(std::string* value) {
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mtktest.NotifyRequest.text)
}

// -------------------------------------------------------------------

// NotifyReply

// -------------------------------------------------------------------

// TextNotify

// string text = 1;
inline void TextNotify::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextNotify::text() const {
  // @@protoc_insertion_point(field_get:mtktest.TextNotify.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TextNotify::set_text(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mtktest.TextNotify.text)
}
inline std::string* TextNotify::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mtktest.TextNotify.text)
  return _s;
}
inline const std::string& TextNotify::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextNotify::_internal_set_text(const std::string& value) {
  ;


  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextNotify::_internal_mutable_text() {
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* TextNotify::release_text() {
  // @@protoc_insertion_point(field_release:mtktest.TextNotify.text)
  return _impl_.text_.Release();
}
inline void TextNotify::set_allocated_text(std::string* value) {
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mtktest.TextNotify.text)
}

// -------------------------------------------------------------------

// TextTransferTask

// uint32 msgid = 1;
inline void TextTransferTask::clear_msgid() {
  _impl_.msgid_ = 0u;
}
inline ::uint32_t TextTransferTask::msgid() const {
  // @@protoc_insertion_point(field_get:mtktest.TextTransferTask.msgid)
  return _internal_msgid();
}
inline void TextTransferTask::set_msgid(::uint32_t value) {
  _internal_set_msgid(value);
  // @@protoc_insertion_point(field_set:mtktest.TextTransferTask.msgid)
}
inline ::uint32_t TextTransferTask::_internal_msgid() const {
  return _impl_.msgid_;
}
inline void TextTransferTask::_internal_set_msgid(::uint32_t value) {
  ;
  _impl_.msgid_ = value;
}

// string text = 2;
inline void TextTransferTask::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextTransferTask::text() const {
  // @@protoc_insertion_point(field_get:mtktest.TextTransferTask.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TextTransferTask::set_text(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mtktest.TextTransferTask.text)
}
inline std::string* TextTransferTask::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mtktest.TextTransferTask.text)
  return _s;
}
inline const std::string& TextTransferTask::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextTransferTask::_internal_set_text(const std::string& value) {
  ;


  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextTransferTask::_internal_mutable_text() {
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* TextTransferTask::release_text() {
  // @@protoc_insertion_point(field_release:mtktest.TextTransferTask.text)
  return _impl_.text_.Release();
}
inline void TextTransferTask::set_allocated_text(std::string* value) {
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mtktest.TextTransferTask.text)
}

// -------------------------------------------------------------------

// LoginTask

// uint64 login_cid = 1;
inline void LoginTask::clear_login_cid() {
  _impl_.login_cid_ = ::uint64_t{0u};
}
inline ::uint64_t LoginTask::login_cid() const {
  // @@protoc_insertion_point(field_get:mtktest.LoginTask.login_cid)
  return _internal_login_cid();
}
inline void LoginTask::set_login_cid(::uint64_t value) {
  _internal_set_login_cid(value);
  // @@protoc_insertion_point(field_set:mtktest.LoginTask.login_cid)
}
inline ::uint64_t LoginTask::_internal_login_cid() const {
  return _impl_.login_cid_;
}
inline void LoginTask::_internal_set_login_cid(::uint64_t value) {
  ;
  _impl_.login_cid_ = value;
}

// uint32 msgid = 2;
inline void LoginTask::clear_msgid() {
  _impl_.msgid_ = 0u;
}
inline ::uint32_t LoginTask::msgid() const {
  // @@protoc_insertion_point(field_get:mtktest.LoginTask.msgid)
  return _internal_msgid();
}
inline void LoginTask::set_msgid(::uint32_t value) {
  _internal_set_msgid(value);
  // @@protoc_insertion_point(field_set:mtktest.LoginTask.msgid)
}
inline ::uint32_t LoginTask::_internal_msgid() const {
  return _impl_.msgid_;
}
inline void LoginTask::_internal_set_msgid(::uint32_t value) {
  ;
  _impl_.msgid_ = value;
}

// bool use_pending = 3;
inline void LoginTask::clear_use_pending() {
  _impl_.use_pending_ = false;
}
inline bool LoginTask::use_pending() const {
  // @@protoc_insertion_point(field_get:mtktest.LoginTask.use_pending)
  return _internal_use_pending();
}
inline void LoginTask::set_use_pending(bool value) {
  _internal_set_use_pending(value);
  // @@protoc_insertion_point(field_set:mtktest.LoginTask.use_pending)
}
inline bool LoginTask::_internal_use_pending() const {
  return _impl_.use_pending_;
}
inline void LoginTask::_internal_set_use_pending(bool value) {
  ;
  _impl_.use_pending_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace mtktest


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::mtktest::ConnectPayload_LoginMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mtktest::ConnectPayload_LoginMode>() {
  return ::mtktest::ConnectPayload_LoginMode_descriptor();
}
template <>
struct is_proto_enum<::mtktest::MessageTypes> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mtktest::MessageTypes>() {
  return ::mtktest::MessageTypes_descriptor();
}
template <>
struct is_proto_enum<::mtktest::ErrorCodes> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mtktest::ErrorCodes>() {
  return ::mtktest::ErrorCodes_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_test_2eproto_2epb_2eh
